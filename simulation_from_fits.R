source("wrAijContext.R")
source("simulate_data.R")

# Returns a list with three components:
#   $expression.data: a matrix of simulated expression data based on the fitted parameters for sim.data.source
#   $operons: List of operons for the simulated expression.data
#   $gold_calls: Matrix of 'gold standard' calls for the simulated expression data
get.sim.data <- function(sim.data.source, type="uniform", fromSaved=TRUE) {
  # sim.data.source: 
  #   If type=="uniform" or "fitted", then any valid "data.source" as specified in Aij_generation_input_data.R
  #   If type=="unfitted", then a numeric vector (see details on discussion of "type")
  # type: One of "uniform", "fitted", or "unfitted", specifying where to get parameters for the data
  #   "uniform" will use fitted values based on (the 2-component operons in) sim.data.source for means and variances
  #     and random values from uniform [0.2,0.8] for mixing parameters
  #   "fitted" will use fitted values based on (the 2-component operons in) sim.data.source for means, variances, and mixing parameters
  #   Both of the above options will generate some 1-component operons by dropping components from fitted 2-component operons
  #     in the same proportion as 1-component operons appear to occur (based on BIC.bonus=0) in sim.data.source
  #   "unfitted" will simply use randomly-generated values for means, variances, and mixing parameters
  #     In this case sim.data.source should be a named list, with the names being parameter names for the function "generate.unfitted.sim.data"
  #     and the corresponding components of the list being the actual parameter values desired. 
  #     For more details on these parameters and their functions see the documentation on "generate.unfitted.sim.data"
  # fromSaved: If TRUE, return the data previously generated by this function (the last time it was run with these parameters). 
  #   If FALSE, re-generate everything.
  #   Regardless of the current value of fromSaved, this function will save its result so that it can be accessed in the future with fromSaved=TRUE

  if(type=="unfitted") savefile <- paste0("Rsave/sim_data_unfitted_",do.call(paste,c(sim.data.source,list(sep="_",collapse="_"))), ".Rdata")
  else savefile <- paste0("Rsave/sim_data_", paste(get.source.str.from.ds(sim.data.source), type, sep="_"), ".Rdata")
  if(fromSaved && file.exists(savefile)) {
    load(savefile)
    return(sim.data)
  } else {
    if(type=="unfitted") {
      cat("Unfitted sim data not found for these parameter values ; generating it\n")
      sim.data <- do.call(generate.unfitted.sim.data, sim.data.source)
    } else {
      cat("Sim data not found for", sim.data.source, type, "; generating it\n")
      sim.data <- generate.sim.data(sim.data.source, type)
    }
    save(sim.data, file=savefile)
    return(sim.data)
  }

}

generate.sim.data <- function(sim.data.source, type) {
  # See comments on get.sim.data for explanations of arguments
  
  library("mvtnorm")
  
  wrAijContext <- get.wrapped.aij.context.from.ds(sim.data.source)
  genenames <- get.genenames(wrAijContext)
  
  split.operons <- do.call(c, lapply(get.operons(wrAijContext), split.to.n.or.shorter, 8))

  one.comp.indices <- get.1comp.operons(wrAijContext, 0)
  genes.in.one.comp.operons <- unlist(get.operons(wrAijContext)[one.comp.indices])
  is.one.comp <- sapply(split.operons, function(operon) operon[1] %in% genes.in.one.comp.operons)
  two.comp.genenames <- setdiff(genenames, genes.in.one.comp.operons)
  
  one.comp.fits <- get.wrapped.1comp.fits(wrAijContext)  # a list of fits, corresponding 1-1 to the operons
  split.1comp.fits <- lapply(split.operons, function(operon) {  # one-comp fits for our (split) operons
    old.operon.index <- which(sapply(get.operons(wrAijContext), function(oldop) operon[1] %in% oldop))  # index in the operons of the operon that gave rise to this (possibly split) one
    old.fit <- one.comp.fits[[old.operon.index]]
    gene.indices <- match(operon, get.operons(wrAijContext)[[old.operon.index]])  # for each gene in our operon, its index in the old operon vector
    our.mean <- old.fit$parameters$mean[gene.indices]  # $parameters$mean is a vector with the mean for each gene in the old operon
    if(length(get.operons(wrAijContext)[[old.operon.index]]) > 1) {
      our.var <- old.fit$parameters$variance$Sigma[gene.indices,gene.indices]  # parameters$variance$Sigma is the covariance matrix for the old operon. This gives us the correct submatrix for our genes.
    } else {
      our.var <- as.matrix(old.fit$parameters$variance$sigmasq[gene.indices])  # parameters$variance is a single number, the variance of each component of the single gene in this old operon. We convert it to the covariance matrix (a 1x1 matrix). gene.indices should be 1 in this case, or else we (rightfully) have an error.
    }
    return(list(mean=our.mean, var=our.var))
  })
  split.2comp.fits <- lapply(split.operons, function(operon) {  # two-comp fits for our (split) operons
    old.operon.index <- which(sapply(get.operons(wrAijContext), function(oldop) operon[1] %in% oldop))  # index in the operons of the operon that gave rise to this (possibly split) one
    gene.indices <- match(operon, get.operons(wrAijContext)[[old.operon.index]])  # for each gene in our operon, its index in the old operon vector
    return(list(
      mu0=get.multi.mu0(wrAijContext)[operon],
      mu1=get.multi.mu1(wrAijContext)[operon],
      var=get.multi.var(wrAijContext)[[old.operon.index]][gene.indices,gene.indices],  # get.multi.var gives a list with the covariance matrix for each old operon. This gives us the correct submatrix for our (possibly split) operon.
      pi=get.multi.pi(wrAijContext)[operon]
    ))
  })

  # now we have one-comp determinations and one/two-comp fits for the real data
  # we'll use this to generate a new set of determinations and one/two-comp fits where we know the real one-comp answers
  
  # Throw out all the old one-comp operons - we don't know the real answer
  new.split.operons <- split.operons[!is.one.comp]
  new.split.1comp.fits <- split.1comp.fits[!is.one.comp]
  new.split.2comp.fits <- split.2comp.fits[!is.one.comp]
  
  # Choose new "one-comp" operons
  percent.1comp.operons <- sum(is.one.comp)/length(is.one.comp)
  num.1comp.operons <- as.integer(percent.1comp.operons * length(new.split.operons))
  new.1comp.indices <- sample(1:length(new.split.operons), size=num.1comp.operons)
  
  # For each new "one-comp" operon, randomly drop one of its components
  dropActive <- runif(n = num.1comp.operons) > 0.5  # Boolean. Drop active if TRUE, inactive if FALSE
  new.is.one.comp <- rep(1, length(new.split.operons))
  new.is.one.comp[new.1comp.indices][dropActive] <- 2
  new.is.one.comp[new.1comp.indices][!dropActive] <- 3
  new.is.one.comp <- factor(new.is.one.comp, labels=c("two-comp", "always-inactive", "always-active"))
  
  # Generate a mixing parameter for each new operon
  mixing.params <- sapply(new.is.one.comp, function(x) {
    if(x == "always-inactive") return(0)
    if(x == "always-active") return(1)
    if(x == "two-comp") {
      if(type == "uniform") return(runif(1, min=0.2, max=0.8))  # choose a uniform random mixing parameter
      if(type == "fitted") {
        if(any(new.split.2comp.fits$pi != new.split.2comp.fits$pi[1])) {
          stop(paste("Expected identical fitted mixing parameter for each gene in the operon", paste(operon, collapse=" ")))
        }
        return(new.split.2comp.fits$pi[1])
      }
      stop(paste("Unrecognized value of 'type':", type))
    }
    stop(paste("Unrecognized value of x:", x))
  })
  
  sim.results.by.operon <- mapply(generate.sim.data.for.operon, 
    numExps = length(get.expnames(wrAijContext)),
    mixing = mixing.params, 
    operon = new.split.operons, 
    mu0 = lapply(new.split.2comp.fits, function(fit) fit$mu0),
    mu1 = lapply(new.split.2comp.fits, function(fit) fit$mu1),
    var = lapply(new.split.2comp.fits, function(fit) as.matrix(fit$var)),  # make sure it's a matrix, even for the 1-gene operon case where there is only one value (a 1x1 matrix)
    SIMPLIFY = FALSE  # leave the result as a list
  )

  # Name rows and columns appropriately
  sim.results.by.operon <- lapply(1:length(sim.results.by.operon), function(index) {
    op.data <- sim.results.by.operon[index]
    operon <- new.split.operons[index]
    rownames(op.data$operon.data) <- rownames(op.data$operon.calls) <- operon
    colnames(op.data$operon.data) <- colnames(op.data$operon.calls) <- get.expnames(wrAijContext)
    return(op.data)
  })
  
  exp.data <- do.call(rbind, lapply(sim.results.by.operon, function(op) op$operon.data))
  gold_calls <- do.call(rbind, lapply(sim.results.by.operon, function(op) op$operon.calls))
  
  # Sort rows into the right order.  Remember we threw out all the old one-comp operons.
  exp.data <- exp.data[two.comp.genenames,]
  gold_calls <- gold_calls[two.comp.genenames,]
  
  return(list(expression.data=exp.data, operons=new.split.operons, gold_calls=gold_calls))
  
}

# This function generates only single-gene operons (for now)
generate.unfitted.sim.data <- function(numGenes, numExps, gene.centers.mean, gene.centers.sd, gene.sd.min, gene.sd.max, meangap.min, meangap.max, mixing.min, mixing.max, onecompPct) {
  # For 2-component genes:
  #   gene centers will be taken from the normal distribution with the given mean and sd
  #   gene sd's will be taken from the uniform-random distribution with the specified endpoints
  #   Likewise for mean gaps (distance between component means, divided by sd) and mixing parameters
  # onecompPct controls the proportion of genes that will be 1-component; 1-component genes are generated by
  #   generating a 2-component gene and randomly dropping one or the other component
  
  gene.centers <- rnorm(numGenes, mean = gene.centers.mean, sd = gene.centers.sd)
  gene.sds <- runif(numGenes, min = gene.sd.min, max = gene.sd.max)
  meangaps <- runif(numGenes, min = meangap.min, max = meangap.max)
  mixing <- runif(numGenes, min = mixing.min, max = mixing.max)
  
  onecompgenes <- sample(numGenes, floor(onecompPct*numGenes))
  mixing[onecompgenes] <- rbinom(length(onecompgenes), 1, 0.5)  # replace mixing parameters randomly with either 0 or 1
  
  results <- lapply(1:numGenes, function(genenum) {
    generate.sim.data.for.operon(
      numExps=numExps, 
      mixing=mixing[genenum], 
      mu0=gene.centers[genenum]-0.5*meangaps[genenum]*gene.sds[genenum],
      mu1=gene.centers[genenum]+0.5*meangaps[genenum]*gene.sds[genenum],
      var=matrix(gene.sds[genenum])
    )
  })
  
  exp.data <- do.call(rbind, lapply(results, `[[`, "operon.data"))
  gold.calls <- do.call(rbind, lapply(results, `[[`, "operon.calls"))
  
  rownames(exp.data) <- rownames(gold.calls) <- paste0("gene",1:numGenes)
  colnames(exp.data) <- colnames(gold.calls) <- paste0("exp",1:numExps)
  
  return(list(expression.data=exp.data, operons=rownames(exp.data), gold_calls=gold.calls))
}

# Split operon in half repeatedly until all pieces are size n or shorter
# Returns a list with the resulting pieces
split.to.n.or.shorter <- function(operon, n) {
  if(length(operon) <= n) return(list(operon))
  splitpoint <- floor(length(operon)/2)
  return(c(
    split.to.n.or.shorter(operon[1:splitpoint], n), 
    split.to.n.or.shorter(operon[(splitpoint+1):length(operon)], n)
  ))
}
